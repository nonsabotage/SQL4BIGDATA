---
title: "Ch6 Webサイトでの行動を把握するためのデータ抽出"
output: 
    html_document:
        toc: true
        toc_float: true
        highlight: tango
        theme: flatly
        css: mycss.css
        code_folding: show
        include:
            - in_header: in_head.html
        df_print: "paged"
  
---


Webサイト特有の指標とそのデータを抽出するＳＱＬ. 
Ｗｅｂサイトの分析ではアクセス解析ツールの使用や機能によっては
目的とする分析が不可能なケースもある. 
自らのＳＱＬで各種データを集計する方法を身につけ、
より詳細な分析が可能になります. 


# コネクションの設定

```{r setup, message=FALSE}

## load libs
libs <- c( "DBI", "RPostgreSQL",  "purrr", "dplyr", "yaml" )
for( lib in libs ) {
    library( lib, character.only=TRUE )  
} 

## connection db
config <-
  read_yaml("config.yaml") %>%
  update_list( drv =  ~  dbDriver(drv))
con <- lift(dbConnect)(config)
knitr::opts_chunk$set(connection = "con")
```


# サイト全体の特徴・傾向を見つける

### サンプルデータ

```{sql}
select
    *
from
    purchase_log
;
```

## 日次の訪問者・訪問回数などを集計する

日次の訪問者数や訪問回数を集計する. 
さらに, 訪問者数に対するページの表示数を求めることで
ユーザー平均の訪問回数を集計する. 


#### 日次のアクセスデータを集計するクエリ

```{sql}

SELECT
  substring(stamp, 1, 10) as dt
  , COUNT(DISTINCT long_session) AS access_users -- 訪問者数
  , COUNT(DISTINCT short_session) AS access_count -- 訪問回数
  , COUNT(*) AS page_view -- ページの表示回数
  , 1. * COUNT(*) / NULLIF(COUNT(DISTINCT long_session), 0) AS pv_per_user
FROM
  access_log
GROUP BY
  -- postgresの場合には, selectで記述した変数名が利用できる
  dt
ORDER BY
  dt
```


## ページ毎の訪問者・訪問回数を集計

ログデータに含まれているURLから集計を試みる

### URL別に集計する

#### URL別に集計するクエリ

```{sql}
SELECT
  url
  , COUNT(DISTINCT short_session) AS access_count
  , COUNT(DISTINCT long_session) AS access_users
  , COUNT(*) AS page_view
FROM
  access_log
GROUP BY
  url
;
```



### パス別に集計する

URLにはクエリパラメータが含まれており, 
集計の単位としては細かい. 
ここではクエリパラメータを省略する書き方を示す. 


#### パス別に集計するクエリ
```{sql}
WITH
access_log_with_path AS (
  SELECT 
    *
    , substring(url from '//[^/]+([^?#]+)') as url_path --パス部分の抽出
  FROM
    access_log
)
SELECT
  url_path
  , COUNT(DISTINCT short_session) AS access_count
  , COUNT(DISTINCT long_session) AS access_users
  , COUNT(*) AS page_view
FROM
  access_log_with_path
GROUP BY
  url_path
;
```

### URLに大きな意味を持たせて集計

もっと細かく集計する. 

#### URLに大きな意味を持たせて集計

```{sql}
WITH
access_log_with_path as (
  SELECT 
    *
    , substring(url from '//[^/]+([^?#]+)') as url_path --パス部分の抽出
  FROM
    access_log
)
, access_log_with_split_path AS (
  SELECT *
  , split_part(url_path, '/', 2) AS path1
  , split_part(url_path, '/', 3) AS path2
  FROM access_log_with_path
)
, access_log_with_page_name as (
  SELECT *
  , CASE
      WHEN path1 = 'list' THEN
        CASE
          WHEN path2 = 'newly' THEN 'newly_list'
          ELSE 'category_list'
        END
      ELSE url_path
    END AS page_name
  FROM access_log_with_split_path
)
SELECT
  page_name
  , COUNT(DISTINCT short_session) AS access_count
  , COUNT(DISTINCT long_session) AS access_users
  , COUNT(*) AS page_view
FROM access_log_with_page_name
GROUP BY page_name
ORDER BY page_name
;
```


## 流入元別に訪問回数やCVR

Webサイトにアクセスする際は, ブラウザに直接ＵＲＬを打ち込む以外は
基本的には他のサイトからアクセスする. 
そのためどのサイトから来たか, つまりは流入経路別に集計することで
訪問者の行動が読み取ることが可能となる. 

### 流入元の判定

次の２つから判定する

- URLパラメータを元に判断
- リファラーのドメインやランディングページで判定

### 流入元別に訪問回数を集計

リファラー, つまりどこから来たのかの情報が空ではなく, 
そのドメインが自サイトではないログを外部流入とする.


#### 流入元別に訪問回数を集計

```{sql}
WITH
access_log_with_parse_info AS (
  SELECT *
  , substring(url from 'https?://([^/]*)') AS url_domain
  , substring(url from 'utm_source=([^&]*)') AS url_utm_source
  , substring(url from 'utm_medium=([^&]*)') AS url_utm_medium
  , substring(referrer from 'https?://([^/]*)') AS referrer_domain
  FROM access_log
)
, access_log_with_via_info AS (
  SELECT *
   , ROW_NUMBER() OVER(ORDER BY stamp) AS log_id
   , CASE
      WHEN url_utm_source <> '' AND url_utm_medium <> ''
        THEN concat(url_utm_source, '-', url_utm_medium)
      WHEN referrer_domain IN ('search.yahoo.co.jp', 'www.google.co.jp') THEN 'search'
      WHEN referrer_domain IN ('twitter.com', 'www.facebook.com') THEN 'social'
      ELSE 'other'
    END AS via
  FROM access_log_with_parse_info
  WHERE COALESCE(referrer_domain, '') NOT IN ('', url_domain)
)
SELECT via, COUNT(1) AS access_count
FROM access_log_with_via_info
GROUP BY via
ORDER BY access_count DESC;
```



### 流入元別にCVRを集計

CVR, つまり訪問に対して購入した割合を集計するクエリを記述する. 

#### 各訪問に対して購入した割合を集計するクエリ


```{sql}
WITH
access_log_with_parse_info AS (
  SELECT *
  , substring(url from 'https?://([^/]*)') AS url_domain
  , substring(url from 'utm_source=([^&]*)') AS url_utm_source
  , substring(url from 'utm_medium=([^&]*)') AS url_utm_medium
  , substring(referrer from 'https?://([^/]*)') AS referrer_domain
  FROM access_log
)
, access_log_with_via_info AS (
  SELECT *
   , ROW_NUMBER() OVER(ORDER BY stamp) AS log_id
   , CASE
      WHEN url_utm_source <> '' AND url_utm_medium <> ''
        THEN concat(url_utm_source, '-', url_utm_medium)
      WHEN referrer_domain IN ('search.yahoo.co.jp', 'www.google.co.jp') THEN 'search'
      WHEN referrer_domain IN ('twitter.com', 'www.facebook.com') THEN 'social'
      ELSE 'other'
    END AS via
  FROM access_log_with_parse_info
  WHERE COALESCE(referrer_domain, '') NOT IN ('', url_domain)
)
, accesss_log_with_purchase_amount AS (
  SELECT
  a.log_id
  , a.via
  , SUM(
      CASE
        WHEN p.stamp::date BETWEEN a.stamp::date AND a.stamp::date + '1 day'::interval
        THEN amount
      END
  ) AS amount -- postgresはinterval型の演算が可能で, 日付でフィルターをしてから, amountを修正
  FROM
    access_log_with_via_info AS a
    LEFT OUTER JOIN
      purchase_log AS p
      ON a.long_session = p.long_session
  GROUP BY a.log_id, a.via
)
SELECT
  via
  , COUNT(1) AS via_count
  , COUNT(amount) AS conversions
  , AVG(100. * SIGN(COALESCE(amount, 0))) AS cvr
  , SUM(COALESCE(amount, 0)) AS amount
  , AVG(1. * COALESCE(amount, 0)) AS avg_amount
FROM
  accesss_log_with_purchase_amount
GROUP BY via 
ORDER BY cvr DESC
;
```


## アクセスされる曜日と時間帯

曜日とアクセスされる時間帯に
ユーザーの特徴はサービスによって異なるため, 
ユーザー像を把握するための材料として利用できる. 

このレポートは次に2手順からなる. 

- 24時間の抽出したい単位を定める
- アクセスされた時価をその単位に丸める
- 曜日と時間をキーにして集計する

#### 曜日・時間帯別の訪問者数を集計するクエリ

```{sql}
WITH
access_log_with_dow AS(
  SELECT 
    stamp
    , date_part('dow', stamp::timestamp) AS dow -- 曜日番号を出力
    , CAST(substring(stamp, 12, 2) AS int) * 60 * 60
      + CAST(substring(stamp, 15, 2) AS int) * 60
      + CAST(substring(stamp, 18, 2) AS int) AS whole_seconds
      
      -- タイムスタンプを切り捨てる秒数を定義
      , 30 * 60 AS interval_seconds
  FROM access_log
)
, access_log_with_floor_seconds AS (
  SELECT 
    stamp
    , dow
    -- interval_timeで丸める処理
    , CAST((floor(whole_seconds / interval_seconds) * interval_seconds) AS int)
      AS floor_seconds
  FROM access_log_with_dow
)
, access_log_with_index AS (
  SELECT
    stamp
    , dow
    -- 総秒数からタイムスタンプの時刻表記に変換
    -- lpaは左詰めの関数
    , lpad(floor(floor_seconds / (60 * 60))::text, 2, '0') || ':'
      || lpad(floor(floor_seconds % (60 * 60) / 60)::text, 2, '0') || ':'
      || lpad(floor(floor_seconds % 60)::text, 2, '0') 
      AS index_time
    FROM access_log_with_floor_seconds
)
SELECT
  index_time
  , COUNT(CASE dow WHEN 0 THEN 1 END) AS sun
  , COUNT(CASE dow WHEN 1 THEN 1 END) AS mon
  , COUNT(CASE dow WHEN 2 THEN 1 END) AS tue
  , COUNT(CASE dow WHEN 3 THEN 1 END) AS wed -- dow が 3のときの1列目, という意味
  , COUNT(CASE dow WHEN 4 THEN 1 END) AS thu
  , COUNT(CASE dow WHEN 5 THEN 1 END) AS fri
  , COUNT(CASE dow WHEN 6 THEN 1 END) AS sat
FROM
  access_log_with_index
GROUP BY
  index_time
ORDER BY
  index_time
;
```

# サイト内のユーザーの行動

Ｗｅｂサイトでの特徴的な指標, たとえば
訪問者数や訪問回数, 直帰率, 離脱率を作成するＳＱＬを作成する. 


## サンプルデータ

転職サイトにおけるアクションログで, 検索タイプを含んでいる.

```{sql}
SELECT * 
FROM activity_log;
```




## 入口ページと出口ページ

最初にアクセスしたページを入り口ページという. 逆に最後にアクセスし, 
離脱をしたページを出口ページという. 

### 集計


```{sql}
WITH 
activity_log_with_landing_exit AS(
  SELECT
    session
    , path
    , stamp
    , FIRST_VALUE(path)
        OVER(
          PARTITION BY session
          ORDER BY stamp ASC
            ROWS BETWEEN UNBOUNDED PRECEDING 
                     AND UNBOUNDED FOLLOWING
        ) AS landing
    , LAST_VALUE(path)
        OVER(
          PARTITION BY session
          ORDER BY stamp ASC
            ROWS BETWEEN UNBOUNDED PRECEDING
                     AND UNBOUNDED FOLLOWING
        ) AS exit
  FROM activity_log
)
, landing_count AS (
  SELECT
    landing AS path
    , COUNT(DISTINCT session) AS count
  FROM
    activity_log_with_landing_exit
  GROUP BY
    landing
)
, exit_count AS (
  SELECT
    exit AS path
    , COUNT(DISTINCT session) AS count
  FROM
    activity_log_with_landing_exit
  GROUP BY exit
)
SELECT 'landing' AS type, * FROM landing_count
UNION ALL
SELECT 'exit' AS type, * FROM exit_count
;

```



### どこから開始してどこで離脱するか

Webサイトはトップページから閲覧を開始するとは
限らないため, どこから閲覧を開始している情報を取得するのは, 
サイトの改善に役立つ. 


```{sql}
WITH 
activity_log_with_landing_exit AS(
  SELECT
    session
    , path
    , stamp
    , FIRST_VALUE(path)
        OVER(
          PARTITION BY session
          ORDER BY stamp ASC
            ROWS BETWEEN UNBOUNDED PRECEDING 
                     AND UNBOUNDED FOLLOWING
        ) AS landing
    , LAST_VALUE(path)
        OVER(
          PARTITION BY session
          ORDER BY stamp ASC
            ROWS BETWEEN UNBOUNDED PRECEDING
                     AND UNBOUNDED FOLLOWING
        ) AS exit
  FROM activity_log
)
SELECT 
  landing
  , exit
  , COUNT(DISTINCT session) AS count
FROM
  activity_log_with_landing_exit
GROUP BY
  landing, exit
;
```


## 離脱率と直帰率


出口ページの離脱率を求めることで, 
問題となるページを洗い出す琴が目的となる. 


### 離脱率の集計

> 離脱率 = 出口数　/ ページビュー

```{sql}

WITH
activity_log_with_exit_flag AS (
  SELECT
    *
    -- 出口ページ判定, sessionのお尻を探している
    , CASE 
        WHEN ROW_NUMBER() OVER(PARTITION BY session ORDER BY stamp DESC) = 1 THEN 1
        ELSE 0
      END AS is_exit
  FROM
    activity_log
)
SELECT
  path
  , SUM(is_exit) AS exit_count
  , COUNT(1) AS page_view
  , AVG(100. * is_exit) AS exit_ratio
FROM
  activity_log_with_exit_flag
GROUP BY path
;



```



### 直帰率

> 直帰率 = 1ページだけ閲覧された訪問回数 / 入り口数

または

> 直帰率 = 1ページだけ閲覧された訪問回数 / 訪問回数

```{sql}
WITH
activity_log_with_landing_bounce_flag AS (
SELECT 
  *
  -- 入り口ページ判定
  , CASE 
      WHEN ROW_NUMBER() OVER(PARTITION BY session ORDER BY stamp ASC) = 1 THEN 1
      ELSE 0
    END AS is_landing
  -- 直帰判定
  , CASE
      WHEN COUNT(1) OVER(PARTITION BY session) = 1 THEN 1
      ELSE 0
    END AS is_bounce
FROM
  activity_log
)
SELECT
  path
  , SUM(is_bounce) AS bounce_count
  , SUM(is_landing) AS landing_count
  , AVG(100. * CASE WHEN is_landing = 1 THEN is_bounce END) AS bounce_ratio
FROM
  activity_log_with_landing_bounce_flag
GROUP BY path
;
```



## 成果に結びつくページを把握

より成果に結びつくページに誘導した方が
Webサイト全体のCVRが向上する. 例えば
検索機能がついているならば, 成果が大きい方を優先して
表示させるなどが考えれる. 


### コンバージョンしたページより前のアクセスにフラグを立てるクエリ
```{sql}
WITH
activity_log_with_conversion_flag AS (
  SELECT
    session
    , stamp
    , path
    -- ここ
    , SIGN(SUM(CASE WHEN path = '/complete' THEN 1 ELSE 0 END)
           OVER(PARTITION BY session ORDER BY stamp DESC
              ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
      ) AS has_conversion
  FROM 
    activity_log
)
SELECT * 
FROM
  activity_log_with_conversion_flag
ORDER BY 
  session, stamp
;
```


```{sql}
WITH 
activity_log_with_conversion_flag AS (
  SELECT
    session
    , stamp
    , path
    -- ここ
    , SIGN(SUM(CASE WHEN path = '/complete' THEN 1 ELSE 0 END)
           OVER(PARTITION BY session ORDER BY stamp DESC
              ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
      ) AS has_conversion
  FROM 
    activity_log
)
SELECT
  path
  , COUNT(DISTINCT session) AS sessions
  , SUM(has_conversion) AS conversions
  , 1. * SUM(has_conversion) / COUNT(DISTINCT session) AS cvr
FROM
  activity_log_with_conversion_flag
GROUP BY
  path
;
```


商品購入や資料請求の場面でCVRは高くなるため, 
CVRを比較するときには同じ階層や類似コンテンツの場合とする.



# コネクションの削除

```{r echo = FALSE, message = FALSE, warning = FALSE }
dbDisconnect( con )
```

















